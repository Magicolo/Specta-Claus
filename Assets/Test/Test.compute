#pragma kernel Update

float Delta;
float Time;
uint Width;
uint Height;
float4 Seed;
float Fade;
float Explode;
Texture2D<float4> VelocityInput;
RWTexture2D<float4> VelocityOutput;
Texture2D<float4> ColorInput;
RWTexture2D<float4> ColorOutput;

Texture2D<float4> CameraInput;
RWTexture2D<float4> CameraOutput;
Texture2D<float4> EmitInput;
RWTexture2D<float4> EmitOutput;
Texture2D<float4> BlurInput;
RWTexture2D<float4> BlurOutput;

uint CursorColumn;
float4 CursorColor;

RWTexture2D<float4> Output;

struct Neighboor
{
    float2 Velocity;
    float2 Residual;
    float4 Color;
};

bool isShorter2(float2 value, float length) {
    return (value.x * value.x + value.y * value.y) < (length * length);
}

bool isLonger2(float2 value, float length) {
    return (value.x * value.x + value.y * value.y) >= (length * length);
}

bool isLonger3(float3 value, float length) {
    return (value.x * value.x + value.y * value.y + value.z * value.z) >= (length * length);
}

bool isLonger4(float4 value, float length) {
    return (value.x * value.x + value.y * value.y + value.z * value.z + value.w * value.w) >= (length * length);
}

uint wrap1(int value, uint bound) {
    value %= bound;
    return value + (value < 0) * bound;
}

uint2 wrap2(int2 value, uint2 bound) {
    return uint2(wrap1(value.x, bound.x), wrap1(value.y, bound.y));
}

float fix1(float value)
{
    if (value > -1E10 && value < 1E10)
        return value;
    else
        return 0;
}

float4 fix4(float4 value)
{
    return float4(fix1(value.x), fix1(value.y), fix1(value.z), fix1(value.w));
}

// Credit: http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl
float3 rgb2hsv(float3 c)
{
    float4 K = float4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
    float4 p = c.g < c.b ? float4(c.bg, K.wz) : float4(c.gb, K.xy);
    float4 q = c.r < p.x ? float4(p.xyw, c.r) : float4(c.r, p.yzx);

    float d = q.x - min(q.w, q.y);
    float e = 1.0e-10;
    return float3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
}

// Credit: http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl
float3 hsv2rgb(float3 c)
{
    float4 K = float4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
    float3 p = abs(frac(c.xxx + K.xyz) * 6.0 - K.www);
    return c.z * lerp(K.xxx, saturate(p - K.xxx), c.y);
}

float polarize1(float value, float amount)
{
    value = clamp(value, 0.0, 1.0) * 2.0 - 1.0;
    amount = clamp(amount, 0.0, 1.0) * 2.0;
    return value / (2.0 - amount + amount * abs(value)) + 0.5;
}

float2 polarize2(float2 value, float amount)
{
    return float2(polarize1(value.x, amount), polarize1(value.y, amount));
}

float3 polarize3(float3 value, float amount)
{
    return float3(polarize1(value.x, amount), polarize1(value.y, amount), polarize1(value.z, amount));
}

float4 polarize4(float4 value, float4 amount)
{
    return float4(polarize1(value.x, amount.x), polarize1(value.y, amount.y), polarize1(value.z, amount.z), polarize1(value.w, amount.w));
}

float random(float2 index)
{
    index += float2(Time, -Time);
    float2 noise = (frac(sin(dot(index, float2(12.9898, 78.233) * 2.0)) * 43758.5453));
    return abs(noise.x + noise.y) * 0.5;
}

float random1(float2 index)
{
    return random(index * Seed.xy);
}

float2 random2(float2 index)
{
    return float2(random(index.xy * Seed.xz), random(index.xy * Seed.yw));
}

float4 sobel(int2 index, int2 size)
{
    float x = 0;
    float y = 0;

    x += length(BlurInput[wrap2(index + int2(-size.x, -size.y), uint2(Width, Height))]) * -1.0;
    x += length(BlurInput[wrap2(index + int2(-size.x, 0), uint2(Width, Height))]) * -2.0;
    x += length(BlurInput[wrap2(index + int2(-size.x, size.y), uint2(Width, Height))]) * -1.0;

    x += length(BlurInput[wrap2(index + int2(size.x, -size.y), uint2(Width, Height))]) * 1.0;
    x += length(BlurInput[wrap2(index + int2(size.x, 0), uint2(Width, Height))]) * 2.0;
    x += length(BlurInput[wrap2(index + int2(size.x, size.y), uint2(Width, Height))]) * 1.0;

    y += length(BlurInput[wrap2(index + int2(-size.x, -size.y), uint2(Width, Height))]) * -1.0;
    y += length(BlurInput[wrap2(index + int2(0, -size.y), uint2(Width, Height))]) * -2.0;
    y += length(BlurInput[wrap2(index + int2(size.x, -size.y), uint2(Width, Height))]) * -1.0;

    y += length(BlurInput[wrap2(index + int2(-size.x, size.y), uint2(Width, Height))]) * 1.0;
    y += length(BlurInput[wrap2(index + int2(0, size.y), uint2(Width, Height))]) * 2.0;
    y += length(BlurInput[wrap2(index + int2(size.x, size.y), uint2(Width, Height))]) * 1.0;

    float value = clamp(sqrt(x * x + y * y), 0.0, 1.0);
    return float4(value, value, value, 1);
}

float4 shift(float4 color, float hue, float saturation, float value)
{
    const float3 hsv = rgb2hsv(color.xyz);
    const float3 rgb = hsv2rgb(float3(hsv.x + hue, hsv.y + saturation, hsv.z + value));
    return float4(rgb, color.w);
}

float4 colorize(float4 color, float amount)
{
    const float3 hsv = rgb2hsv(color.xyz);
    const float3 rgb = hsv2rgb(float3(hsv.x, clamp(hsv.y * (1.0 + amount), 0.0, 1.0), hsv.z));
    return float4(rgb, color.w);
}

Neighboor neighboor(uint2 index, int2 direction)
{
    index += direction;
    float4 color = ColorInput[index];
    float4 velocity = VelocityInput[index];
    float2 previous = velocity.xy * Delta + velocity.zw;
    float2 absolute = abs(previous);
    // If true, this direction is the dominant one for this velocity.
    bool align = dot(normalize(previous), normalize(-direction)) > 0.92388;
    // Reprensents which components cause a move.
    bool2 move = absolute >= float2(1, 1);

    Neighboor neighboor;
    neighboor.Velocity = velocity.xy * align * any(move);
    // If a component wasn't used for this move, store it in the residual.
    neighboor.Residual = previous * align * any(move) * !move;
    neighboor.Color = color * align * any(move);
    return neighboor;
}

[numthreads(8,4,1)]
void Update(uint3 id : SV_DispatchThreadID)
{
    // TODO: Explode!
    const float CameraJitter = 10;
    const float CameraThreshold = 0.5;
    const float CameraContrast = 2.5;
    const float CameraColorize = 2.5;

    const float ParticleFriction = 15;
    const float ParticleFade = 15;
    const float ParticleTrail = 25;
    const float ParticleColorize = 2.5;

    const float CursorTrail = 100;
    const float CursorFade = 25;
    const float CursorBlend = 0;

    const int2 EmitRadius = int2(2, 5);
    const float EmitPower = 2.5;
    const float2 EmitForce = float2(50, 250);
    const float2 EmitForward = float2(0.5, 1);
    const float EmitPolarize = 0.75;
    const float EmitColorize = 10;

    const float BlurInside = 0.25;
    const float BlurOutline = 2.5;
    const float BlurSobel = 5;
    const float BlurJitter = 5;

    const int EdgeSize = 1;
    const float EdgeThreshold = 0.1;
    const float EdgeSpeed = 5;
    const float EdgeShine = 5;

    const float4 color = ColorInput[id.xy];
    const float4 velocity = VelocityInput[id.xy];
    const float2 previous = velocity.xy * Delta + velocity.zw;
    const bool stay = all(abs(previous) < float2(1, 1)) * isLonger4(color, 0.1);
    const float friction = clamp(1.0 - ParticleFriction * Delta, 0.0, 1.0);
    const float fade = clamp(1.0 - ParticleFade * Delta, 0.0, 1.0);
    const float trail = stay + !stay * clamp(ParticleTrail * Delta, 0.0, 1.0);
    float2 seed = random2(id.xy);

    Neighboor neighboor1 = neighboor(id.xy, int2(-1, 1));
    Neighboor neighboor2 = neighboor(id.xy, int2(0, 1));
    Neighboor neighboor3 = neighboor(id.xy, int2(1, 1));
    Neighboor neighboor4 = neighboor(id.xy, int2(1, 0));
    Neighboor neighboor5 = neighboor(id.xy, int2(1, -1));
    Neighboor neighboor6 = neighboor(id.xy, int2(0, -1));
    Neighboor neighboor7 = neighboor(id.xy, int2(-1, -1));
    Neighboor neighboor8 = neighboor(id.xy, int2(-1, 0));

    float2 particleVelocity =
        velocity.xy * stay +
        neighboor1.Velocity +
        neighboor2.Velocity +
        neighboor3.Velocity +
        neighboor4.Velocity +
        neighboor5.Velocity +
        neighboor6.Velocity +
        neighboor7.Velocity +
        neighboor8.Velocity;
    particleVelocity *= friction;
    particleVelocity = clamp(particleVelocity, -1000000, 1000000);

    float2 particleResidual =
        previous * stay +
        neighboor1.Residual +
        neighboor2.Residual +
        neighboor3.Residual +
        neighboor4.Residual +
        neighboor5.Residual +
        neighboor6.Residual +
        neighboor7.Residual +
        neighboor8.Residual;
    particleResidual *= friction;
    particleResidual = clamp(particleResidual, -1000000, 1000000);

    float4 particleColor =
        color * trail +
        neighboor1.Color +
        neighboor2.Color +
        neighboor3.Color +
        neighboor4.Color +
        neighboor5.Color +
        neighboor6.Color +
        neighboor7.Color +
        neighboor8.Color;
    particleColor *= fade;
    particleColor = colorize(particleColor, ParticleColorize * Delta);
    particleColor = clamp(particleColor, 0, 100);


    const bool cursorBehind = id.x <= CursorColumn;
    const float cursorWrap = cursorBehind * float(id.x) + (id.x > CursorColumn) * (float(id.x) - float(Width));
    const float cursorTrail = 1.0 - clamp((CursorColumn - cursorWrap) / CursorTrail, 0.0, 1.0);
    const float cursorFade = pow(abs(cursorTrail), CursorFade);
    const float4 cursorColor = cursorFade * CursorColor;


    float4 cameraInput = CameraInput[id.xy];
    cameraInput = pow(abs(cameraInput), CameraContrast);
    cameraInput = colorize(cameraInput, CameraColorize);
    const bool cameraValid = any(cameraInput.xyz >= float3(CameraThreshold, CameraThreshold, CameraThreshold));
    cameraInput *= cameraValid;
    const float cameraJitter = clamp(CameraJitter * Delta, 0.0, 1.0);
    const float4 cameraOutput = lerp(CameraOutput[id.xy], cameraInput, cameraJitter);


    const uint edgePixels = pow(EdgeSize * 2 + 1, 2);
    uint edges = 0;
    for (int x = -EdgeSize; x <= EdgeSize; x++)
    {
        for (int y = -EdgeSize; y <= EdgeSize; y++)
        {
            const int2 index = wrap2(id.xy + int2(x, y), uint2(Width, Height));
            edges += any(BlurInput[index].rgb > float3(EdgeThreshold, EdgeThreshold, EdgeThreshold));
        }
    }


    const float blurFade = 1.0 - Delta * Fade;
    const float4 blurInput = BlurInput[id.xy];
    const float4 blurOutput = blurInput * blurFade + cameraOutput * clamp(10.0 - length(blurInput), 0.0, 1.0);
    const float4 blurOutline = blurOutput * (sin(Time * EdgeSpeed) * EdgeShine * 0.5 + EdgeShine) * (edges < edgePixels) * BlurOutline;
    const float4 blurSobel =
        blurOutput * sobel(id.xy, int2(sin(Time * 0.93) * 1 + 2, sin(Time * 1.31) * 2 + 3)) * 0.4 * BlurSobel +
        blurOutput * sobel(id.xy, int2(sin(Time * 0.53) * 3 + 5, sin(Time * 0.71) * 4 + 6)) * 0.3 * BlurSobel +
        blurOutput * sobel(id.xy, int2(sin(Time * 0.37) * 5 + 7, sin(Time * 1.21) * 6 + 8)) * 0.2 * BlurSobel +
        blurOutput * sobel(id.xy, int2(sin(Time * 1.87) * 7 + 10, sin(Time * 1.29) * 8 + 11)) * 0.1 * BlurSobel;
    const float4 blurInside = lerp(blurOutput * BlurInside, blurSobel / BlurSobel, pow(length(blurSobel.rgb), 0.25));
    const float4 blurColor = lerp(EmitInput[id.xy], blurInside + blurOutline, Delta * (BlurJitter + Fade));


    float2 emitVelocity = float2(0, 0);
    float4 emitColor = float4(0, 0, 0, 0);
    for (int y = -EmitRadius.y; y <= EmitRadius.y; y++) {
        const int2 target = int2(CursorColumn, int(id.y) + y);
        const float4 input = EmitInput[target];
        const float power = pow(clamp(max(max(input.x, input.y), input.z) * 0.25, 0.0, 1.0), EmitPower);
        const float distance = length(float2(target) - float2(id.xy));
        const float radius = lerp(float(EmitRadius.x), float(EmitRadius.y), power);
        const float fade = 1.0 - clamp(distance / radius, 0.0, 1.0);
        const float4 color = lerp(input, CursorColor, CursorBlend) * fade;
        const float2 random = seed = random2(target * seed);
        const float force = lerp(EmitForce.x, EmitForce.y, power);
        const float forward = lerp(EmitForward.x, EmitForward.y, power);
        const float2 velocity = float2(lerp(-force, force * forward, random.x), lerp(-force, force, random.y));
        emitVelocity += velocity * any(input) * any(color);
        emitColor += color * any(input);
    }
    const float4 emitPolarize = polarize4(emitColor, float4(EmitPolarize, EmitPolarize, EmitPolarize, 0));
    const float4 emitColorize = colorize(emitPolarize, EmitColorize);
    const float emitBehind = clamp(cursorBehind + Explode, 0.0, 1.0);
    emitColor = emitBehind * emitColorize;


    VelocityOutput[id.xy] = fix4(float4(particleVelocity + emitVelocity, particleResidual));
    ColorOutput[id.xy] = fix4(particleColor + emitColor);
    EmitOutput[id.xy] = fix4(blurColor);
    BlurOutput[id.xy] = fix4(blurOutput);
    CameraOutput[id.xy] = fix4(cameraOutput);
    Output[id.xy] = fix4(clamp(particleColor + emitColor + cursorColor + blurColor, 0, 100));
}